# =====================================================================
# nginx/app.conf (Reverse Proxy for NestJS API)
#
# - Handles ALL external HTTP/HTTPS traffic.
# - Forwards requests internally to the "api" container (port 3000).
# - Adds gzip compression, timeouts, rate limiting, and TLS support.
# =====================================================================

# ---- Rate limiting config ----
# Each client IP gets 100 requests/minute.
# Stored in 10MB shared memory segment.
limit_req_zone $binary_remote_addr zone=perip:10m rate=100r/m;

# ---- Define upstream API target ----
# Docker DNS: the service name "api" points to the API container.
# keepalive keeps TCP connections warm.
upstream api_upstream {
    server api:3000;
    keepalive 64;
}

# =====================================================================
# Server block for HTTP (port 80)
# =====================================================================
server {
    listen 80 default_server;
    server_name _; # catch-all

    # Redirect ALL HTTP traffic to HTTPS (port 443)
    return 301 https://$host$request_uri;
}

# =====================================================================
# Server block for HTTPS (port 443)
# =====================================================================
server {
    listen 443 ssl http2;   # Enable TLS + HTTP/2
    server_name _;          # catch-all (you don’t have domain, so "_" works)

    # ---- TLS certificates ----
    # Self-signed certs (or later Let’s Encrypt if domain added)
    ssl_certificate     /etc/ssl/onprem/selfsigned.crt;
    ssl_certificate_key /etc/ssl/onprem/selfsigned.key;

    # ---- Security headers ----
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;
    add_header X-Content-Type-Options nosniff;
    add_header X-Frame-Options DENY;
    add_header X-XSS-Protection "1; mode=block";

    # ---- Gzip compression ----
    gzip on;
    gzip_min_length 1024;  # only compress if bigger than 1KB
    gzip_comp_level 5;     # sensible default (1-9, higher = more CPU)
    gzip_types
        text/plain
        text/css
        text/javascript
        application/json
        application/javascript
        application/xml
        application/xml+rss
        image/svg+xml;

    # ------------ Safety & timeouts ------------
    client_max_body_size 10m;  # allow request bodies (uploads) up to ~10MB
    keepalive_timeout 65s;     # how long NGINX keeps client TCP connections open
    proxy_read_timeout 60s;    # how long NGINX waits for the API to send a response
    proxy_send_timeout 60s;    # how long NGINX waits when sending data to the API
    proxy_connect_timeout 5s;  # how long to wait when opening a connection to the API

    # ---- Health check endpoint ----
    location /health {
        # No request limiting for health checks
        # (Equivalent to not applying "limit_req" here.)
        proxy_pass http://api_upstream/health;

        # Use HTTP/1.1 + keepalive towards upstream
        proxy_http_version 1.1;
        proxy_set_header Connection "";

        # Forward original client details to the API (helps with logs & auth)
        proxy_set_header Host              $host;
        proxy_set_header X-Real-IP         $remote_addr;
        proxy_set_header X-Forwarded-For   $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    # ---- All other API requests ----
    location / {
        # Apply the 100 req/min per IP with a small "burst" allowance.
        # burst=50 lets short spikes pass; nodelay processes immediately (excess gets 429).
        limit_req zone=perip burst=50 nodelay;

        proxy_pass http://api_upstream;

        # Keep connections to the API warm (fewer TCP handshakes)
        proxy_http_version 1.1;
        proxy_set_header Connection "";

        # Forward original client info
        proxy_set_header Host              $host;
        proxy_set_header X-Real-IP         $remote_addr;
        proxy_set_header X-Forwarded-For   $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
}
